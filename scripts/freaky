local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualUser = game:GetService("VirtualUser")

-- GUI Creation
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoFarmGUI"
ScreenGui.ResetOnSpawn = false -- Make GUI persist after death
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 200, 0, 150)
Frame.Position = UDim2.new(0.8, 0, 0.5, 0)
Frame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
Frame.BorderSizePixel = 0
Frame.Parent = ScreenGui

local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0.8, 0, 0.3, 0)
ToggleButton.Position = UDim2.new(0.1, 0, 0.1, 0)
ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
ToggleButton.Text = "AutoFarm: OFF"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Parent = Frame

local HitboxButton = Instance.new("TextButton")
HitboxButton.Size = UDim2.new(0.8, 0, 0.3, 0)
HitboxButton.Position = UDim2.new(0.1, 0, 0.5, 0)
HitboxButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
HitboxButton.Text = "Hitbox Expand: OFF"
HitboxButton.TextColor3 = Color3.fromRGB(255, 255, 255)
HitboxButton.Parent = Frame

-- Variables
local isAutoFarming = false
local isHitboxExpanded = false
local targetPlayer = nil
local spawnArea = workspace:FindFirstChild("SpawnArea")
local lastAttackTime = 0
local attackCooldown = 1.4
local spawnPosition = Vector3.new(-0.499996185, 65.5, 294.5)
local isAtTarget = false
local hasClicked = false
local objectCount = 0
local isWaitingForE = false
local teleportStartTime = 0
local currentTool = nil

-- Functions
local function isPlayerInSpawnArea(player)
    if not spawnArea then return false end
    
    local character = player.Character
    if not character then return false end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local position = humanoidRootPart.Position
    local size = spawnArea.Size
    local center = spawnArea.Position
    
    return math.abs(position.X - center.X) <= size.X/2 and
           math.abs(position.Y - center.Y) <= size.Y/2 and
           math.abs(position.Z - center.Z) <= size.Z/2
end

local function isPlayerInBounds(player)
    if not player or not player.Character then return false end
    
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local pos = humanoidRootPart.Position
    
    -- Check if player is within the X and Z boundaries (Y/height doesn't matter)
    return pos.X >= -251.667236328125 and pos.X <= 170.11148071289062 and
           pos.Z >= -204.44935607910156 and pos.Z <= 133.97195434570312
end

local function getRandomPlayer()
    local players = Players:GetPlayers()
    local validPlayers = {}
    
    for _, player in ipairs(players) do
        if player ~= LocalPlayer and 
           player.Character and 
           not isPlayerInSpawnArea(player) and
           isPlayerInBounds(player) then
            table.insert(validPlayers, player)
        end
    end
    
    if #validPlayers > 0 then
        return validPlayers[math.random(1, #validPlayers)]
    end
    return nil
end

local function setupCharacter(character)
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        rootPart.Velocity = Vector3.new(0, 0, 0)
    end
end

local function expandHitbox(tool)
    if not tool or not isHitboxExpanded then return end
    
    for _, part in ipairs(tool:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Size = part.Size * 1.5
            part.Transparency = 0.5
        end
    end
end

local function createHitbox()
    local hitbox = Instance.new("Part")
    hitbox.Name = "Hitbox"
    hitbox.Size = Vector3.new(4, 4, 4)
    hitbox.Transparency = 0.5
    hitbox.Color = Color3.fromRGB(255, 0, 0)
    hitbox.Anchored = true
    hitbox.CanCollide = false
    hitbox.Parent = workspace
    return hitbox
end

local function createToolHitbox()
    local hitbox = Instance.new("Part")
    hitbox.Name = "ToolHitbox"
    hitbox.Size = Vector3.new(2, 2, 2)
    hitbox.Transparency = 0.5
    hitbox.Color = Color3.fromRGB(0, 255, 0)
    hitbox.Anchored = true
    hitbox.CanCollide = false
    hitbox.Parent = workspace
    return hitbox
end

local function updateHitbox(hitbox, position)
    if hitbox then
        hitbox.CFrame = CFrame.new(position)
    end
end

local function updateToolHitbox(hitbox, tool)
    if not hitbox or not tool then return end
    
    local handle = tool:FindFirstChild("Handle") or tool:FindFirstChildOfClass("BasePart")
    if handle then
        hitbox.CFrame = handle.CFrame
        hitbox.Size = handle.Size * 1.5
    end
end

local function teleportToPlayer(player)
    if not player or not player.Character then return end
    
    local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
    local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    if targetRoot and localRoot then
        local targetPosition = targetRoot.Position + Vector3.new(0, -6, 0)
        localRoot.CFrame = CFrame.new(targetPosition)
        localRoot.Velocity = Vector3.new(0, 0, 0)
        return targetPosition
    end
    return nil
end

local function teleportToSpawn()
    local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if localRoot then
        localRoot.CFrame = CFrame.new(spawnPosition)
        localRoot.Velocity = Vector3.new(0, 0, 0)
    end
end

local function performAttack()
    -- Use VirtualUser for clicking
    VirtualUser:Button1Down(Vector2.new(0, 0))
    wait(0.1)
    VirtualUser:Button1Up(Vector2.new(0, 0))
    
    lastAttackTime = tick()
    hasClicked = true
    objectCount = objectCount + 1
end

local function pressE()
    -- Use VirtualInputManager for E press
    game:GetService("VirtualInputManager"):SendKeyEvent(true, "E", false, game)
    wait(0.1)
    game:GetService("VirtualInputManager"):SendKeyEvent(false, "E", false, game)
end

local function getCurrentTool()
    -- Check backpack first
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local tool = backpack:FindFirstChild("Wooden Skewer")
        if tool then
            return tool
        end
    end
    
    -- Check character
    local character = LocalPlayer.Character
    if character then
        local tool = character:FindFirstChild("Wooden Skewer")
        if tool then
            return tool
        end
    end
    
    return nil
end

local function countObjectsInFolders()
    local count = 0
    
    -- Check backpack path
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local toolFolder = backpack:FindFirstChild("Wooden Skewer")
        if toolFolder then
            local bodiesFolder = toolFolder:FindFirstChild("Bodies")
            if bodiesFolder then
                count = count + #bodiesFolder:GetChildren()
            end
        end
    end
    
    -- Check workspace path - look for any player's folder
    for _, player in ipairs(Players:GetPlayers()) do
        local workspaceFolder = workspace:FindFirstChild(player.Name)
        if workspaceFolder then
            local toolFolder = workspaceFolder:FindFirstChild("Wooden Skewer")
            if toolFolder then
                local bodiesFolder = toolFolder:FindFirstChild("Bodies")
                if bodiesFolder then
                    count = count + #bodiesFolder:GetChildren()
                end
            end
        end
    end
    
    return count
end

-- Character Setup
LocalPlayer.CharacterAdded:Connect(setupCharacter)
if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end

-- Toggle Button Logic
ToggleButton.MouseButton1Click:Connect(function()
    isAutoFarming = not isAutoFarming
    ToggleButton.BackgroundColor3 = isAutoFarming and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    ToggleButton.Text = "AutoFarm: " .. (isAutoFarming and "ON" or "OFF")
    
    if isAutoFarming then
        targetPlayer = getRandomPlayer()
    end
end)

HitboxButton.MouseButton1Click:Connect(function()
    isHitboxExpanded = not isHitboxExpanded
    HitboxButton.BackgroundColor3 = isHitboxExpanded and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    HitboxButton.Text = "Hitbox Expand: " .. (isHitboxExpanded and "ON" or "OFF")
end)

-- Create hitboxes
local hitbox = createHitbox()
local toolHitbox = createToolHitbox()

-- Main Loop
RunService.Heartbeat:Connect(function()
    local currentTime = tick()
    
    -- Update current tool
    currentTool = getCurrentTool()
    
    -- Always check object count
    objectCount = countObjectsInFolders()
    
    if isWaitingForE then
        if currentTime - lastAttackTime >= 5 then
            isWaitingForE = false
            objectCount = 0
        end
        return
    end
    
    if isAtTarget then
        -- At target, teleport constantly and check for attack
        if targetPlayer and targetPlayer.Character then
            -- Check if target is still in bounds
            if not isPlayerInBounds(targetPlayer) then
                isAtTarget = false
                hasClicked = false
                teleportToSpawn()
                return
            end
            
            local targetPosition = teleportToPlayer(targetPlayer)
            if targetPosition then
                updateHitbox(hitbox, targetPosition)
                
                -- Update tool hitbox
                if currentTool then
                    updateToolHitbox(toolHitbox, currentTool)
                end
            end
            
            if not hasClicked then
                if currentTime - teleportStartTime >= 0.5 then
                    performAttack()
                end
            elseif hasClicked and currentTime - lastAttackTime >= 1.0 then
                -- After clicking, wait 1 second then go to spawn
                teleportToSpawn()
                isAtTarget = false
                hasClicked = false
                hitbox.Transparency = 1 -- Hide hitboxes when at spawn
                toolHitbox.Transparency = 1
                
                -- Check if we need to press E
                if objectCount >= 5 then
                    pressE()
                    isWaitingForE = true
                    teleportToSpawn() -- Ensure we're at spawn when pressing E
                end
            end
        end
    else
        -- At spawn, wait 1.5 seconds then find new target
        if currentTime - lastAttackTime >= 1.5 then
            targetPlayer = getRandomPlayer()
            if targetPlayer then
                isAtTarget = true
                teleportStartTime = tick() -- Reset teleport time when finding new target
                hitbox.Transparency = 0.5 -- Show hitboxes when targeting
                toolHitbox.Transparency = 0.5
            end
        end
    end
end)

-- Cleanup
game:BindToClose(function()
    if hitbox then
        hitbox:Destroy()
    end
    if toolHitbox then
        toolHitbox:Destroy()
    end
end)

-- Make GUI Draggable
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    Frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

Frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = Frame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

Frame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end) 
